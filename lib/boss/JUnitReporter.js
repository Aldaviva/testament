var _         = require('lodash');
var config    = require('../common/config');
var fs        = require('fs');
var logger    = require('../common/logger')(__filename);
var my        = require('myclass');
var path      = require('path');
var XMLWriter = require('xml-writer');
var Q = require('q');

/**
 * References:
 *  http://nelsonwells.net/2012/09/how-jenkins-ci-parses-and-displays-junit-output/
 *  http://stackoverflow.com/questions/4922867/junit-xml-format-specification-that-hudson-supports
 *  https://svn.jenkins-ci.org/trunk/hudson/dtkit/dtkit-format/dtkit-junit-model/src/main/resources/com/thalesgroup/dtkit/junit/model/xsd/junit-4.xsd
 */

var JUnitReporter = module.exports = my.Class({

	STATIC: {
		MESSAGE_TO_EVENT: {
			'runner-start' : 'onRunnerStart',
			'suite-start'  : 'onSuiteStart',
			'case-pass'    : 'onTestPass',
			'case-fail'    : 'onTestFail',
			'case-skip'    : 'onTestSkip',
			'suite-end'    : 'onSuiteEnd',
			'runner-end'   : 'onRunnerEnd'
		}
	},

	xml                 : null,
	target              : null,
	mostRecentSuiteName : null,
	writeStream: null,
	writeStreamEndedDeferred: null,

	constructor: function(target){
		_.bindAll(this);
		this.target = target;

		this.writeStreamEndedDeferred = Q.defer();
		var filename = path.join(config.app.reports.dir, this.target+'.xml');
		if(!fs.existsSync(config.app.reports.dir)){
			fs.mkdirSync(config.app.reports.dir);
		}

		this.writeStream = fs.createWriteStream(filename);
		this.xml = new XMLWriter(true, _.bind(function(string, encoding){
			this.writeStream.write(string, encoding);
		}, this));

		this.xml.startDocument('1.0', 'UTF-8');
	},

	getWriteStreamEndedPromise: function(){
		return this.writeStreamEndedDeferred.promise;
	},

	processMessage: function(msg, head, info){
		var eventName = info.routingKey.split('.')[3];
		var handlerMethod = JUnitReporter.MESSAGE_TO_EVENT[eventName];
		handlerMethod && this[handlerMethod] && this[handlerMethod](msg);
	},

	onRunnerStart: function(runner){
		this.xml.startElement('testsuites');
	},

	onSuiteStart: function(suite){
		/* Do nothing
		 * junit testsuite elements cannot nest, as opposed to BDD infinite nesting depth
		 * therefore, testsuite elements are generated by testpass/fail events when a change in test.parentFullTitle is detected
		 */
	},

	onTestPass: function(test){
		this._writeTestCase(test.title, test.suiteFullTitle, test.duration);
		this.xml.endElement();
	},

	onTestFail: function(test){
		this._writeTestCase(test.title, test.suiteFullTitle, test.duration);

		this.xml.startElement('error');

		var message = test.err.message;
		var stack = test.err.stack;

		message && this.xml.writeAttribute('message', message);
		stack && this.xml.text(stack);
		this.xml.endElement();

		this.xml.endElement();
	},

	onTestSkip: function(test){
		this._writeTestCase(test.title, test.suiteFullTitle, test.duration);
		this.xml.writeElement("skipped", "");
		this.xml.endElement();
	},

	onSuiteEnd: function(suite){
		/* Do nothing
		 * see onSuiteStart() for explanation
		 */
	},

	onRunnerEnd: function(runner){
		if(this.mostRecentSuiteName !== null){
			this.xml.endElement();
		}

		this.xml.endElement();
		this.xml.endDocument();

		this.writeStream.end(_.bind(function(){
			this.writeStreamEndedDeferred.resolve();
		}, this));
	},

	_writeTestCase: function(testName, suiteName, durationMillis){
		this._ensureSuiteElement(suiteName);
		this.xml.startElement('testcase');
		this.xml.writeAttribute('name', testName);
		this.xml.writeAttribute('classname', suiteName);
		this.xml.writeAttribute('time', String(durationMillis/1000));
	},

	_ensureSuiteElement: function(suiteName){
		if(this.mostRecentSuiteName !== suiteName){
			if(this.mostRecentSuiteName !== null){
				this.xml.endElement();
			}

			this.xml.startElement('testsuite');
			this.xml.writeAttribute('name', suiteName);
			this.mostRecentSuiteName = suiteName;
		}
	}
});